# Liquid staking pool
Liquid Staking (LSt) - это протокол, который соединяет держателей TON всех калибров 
с операторами аппаратных узлов для участия в проверке TON Blockchain через объединение активов.

Держатели TON, они же *Номинаторы*, вносят средства в пул и получают джеттоны Pool, которые могут быть использованы в любом протоколе DeFi.
Эти джеттоны представляют собой долю в пуле и увеличивают стоимость TON за счет начисления вознаграждения за валидацию.

Операторы узлов могут работать на пул, используя его средства в качестве валидационной ставки и получая вознаграждение за валидацию.

**Больше информации в [документации](https://ton-ls-protocol.gitbook.io/ton-liquid-staking-protocol/)**.

## Работа с кодом
- Клонируйте репо со всеми подмодулями: `git clone --recurse-submodules <git-url>`.
- Установите зависимости (вам нужен Node v18+): `npm install`.
- Соберите все контракты: `npx blueprint build --all`.
- Запустить тесты: `npm test -- tests/*.ts` (стандартный `npx blueprint test` не будет работать корректно из-за тестов в подмодулях. Чтобы запустить их, измените dir на подмодуль и запускайте тесты оттуда)
- Запустите скрипт развертывания (внимательно прочитайте его и проверьте, что он делает то, что вы хотите): `npx blueprint run`

## Техническое описание
### Термины
- elector: смарт-контракт, который принимает ставки, проводит выборы, определяет следующие активные ключи валидатора и распределяет вознаграждение за валидацию
- Контроллер: смарт-контракт, который управляет средствами для ставок 
- валидатор: агент, который управляет узлом TON и (пытается) участвовать в выборах, а в случае избрания валидирует новые блоки. Он знает свой приватный ключ валидатора, а также "частично" контролирует свой собственный контроллер (может отправлять и получать ставки, но не может снимать все деньги для себя)
- номинатор: участник, у которого есть активы (TON) и который хочет одолжить их валидаторам через JettonPool, чтобы получить с этого проценты
- джеттоны: TEP-74+TEP-89 Jettons : масштабируемые токены на блокчейне TON

### Схема

![scheme](docs/images/scheme.png)

**Валидаторы** участвуют в выборах через **Сонтроллер**, который

1. Запрашивает средства из пула валидаторов после получения **одобрения валидаторов**.
2. принимает и учитывает средства от валидационного пула и валидаторов
3. следит за тем, чтобы активы, предоставленные валидаторам, не могли быть изъяты
4. отправляет ставку плюс оговоренный процент по кредиту после раунда валидации в пул валидации.

**Пул** Центральный контракт:
  - Взаимодействие с контроллерами
    1. Одалживает активы контролерам по запросу на заем от **Контролера** в соответствии с *Текущей ставкой*.
    2. Получает активы и агрегирует информацию о прибыли/убытках от **Сонтроллеров**.
  - Взаимодействие со стакерами
    3. управляет депозитами и снятием средств
  - Взаимодействие с менеджером по процентам:
    4. отправляет агрегированную статистику по кредитным раундам
    5. обновляет проценты по запросу менеджера по процентам
  - Взаимодействие с губернатором:
    6. отправляет долю прибыли
    7. обновляет параметры по запросу: параметры вклада (open?, optimistic?), роли (halter, sudoer, interest_manager, governor), состояние (unhalt).

**пул jetton** - это jetton, который используется для управления активами, одолженными пулу. Он также имеет возможности DAO-голосования, которые можно использовать для голосования за параметры конфигурации сети.

**Пополнение/снятие**: соотношение пула jetton/TON обновляется раз в раунд. В строгом режиме мы предполагаем, что это соотношение неизвестно до конца раунда, и поэтому фактические депозиты/снятия должны быть отложены до конца раунда. Кроме того, даже в оптимистичном режиме (когда депозиты/снятия обрабатываются через прогнозируемое соотношение), снятия часто не могут быть сделаны, если у пула нет достаточного количества TON. Таким образом, **Deposits/Withdrawals** - это специальные контракты, которые представляют собой депозиты/снятия в процессе. Они могут быть реализованы как NFT или Jettons, так что все кошельки смогут взаимодействовать с ними.

#### Роли

**Halter**
При необходимости останавливает работу всех частей системы.

**Sudoer**
Пустая по умолчанию роль, которая может отправлять произвольные сообщения из произвольной части системы. Sudoer становится активным, только если установлен более *sudoer_threshold* секунд назад (ожидается, что 24 часа). Возможность обновления кода и прямого обновления данных.

**Апроверщик**
Роль, позволяющая одобрять запросы Контроллеров на займы.

**Менеджер по процентам**.
Получает статистику по раундам и обновляет параметры процентов

**Губернатор** 
1. устанавливает другие роли в **Pool**, **Controller**, **Minters**
2. устанавливать некоторые параметры (плата за управление) в **Pool**.


Каждая роль может выполняться кошельком, кошельком с несколькими подписями или DAO. Ожидается, что в финальной редакции:
- *Halter* будет горячим кошельком, который сканирует блокчейн и останавливает все в случае неожиданного поведения.
- *Approver* будет либо холодным кошельком, либо объединенным с *Governance
- *Interest Manager* будет смарт-контрактом, который реализует некоторую логику равновесия
- *Управление* будет представлять собой DAO на основе джеттона с собственным GJ: governance jetton. Опционально может быть добавлен фильтр исходящих сообщений, запрещающий установку sudoer и других параметров.

## Оптимистичные депозиты/выводы средств
По умолчанию предполагается, что соотношение пул джеттон/ТОН непредсказуемо, так как валидаторы могут быть разрезаны, и поэтому невозможно со 100% вероятностью сказать, насколько изменится баланс пула по итогам раунда. Если, действительно, соотношение может колебаться в обе стороны (увеличиваться и уменьшаться), то нам нужно отложить все депозиты и снятия и обрабатывать их сразу по окончании раунда. В противном случае, если, допустим, кто-то знает, что пул валидаторов будет сильно сокращен, и снимет средства до этого, он понесет убытки, распределив их среди других держателей.

Однако, поскольку протокол гарантирует, что у валидатора достаточно средств для уплаты ожидаемых штрафов, а проценты по кредиту оговорены при выдаче кредита, при нормальных условиях количество возвращенных TON в конце раунда определяется, и таким образом можно рассчитать прогнозируемое соотношение пула jetton / TON. Учитывая это, можно обрабатывать депозиты и снятия в *оптимистичном* режиме: депозиты конвертировать в пул джеттон, исходя из прогнозируемого соотношения на конец раунда, а снятия конвертировать в TON, исходя из текущего соотношения (в таком виде средства не работают в раунде). Этот оптимистичный режим должен быть активирован только в том случае, если существуют меры по защите от попыток обмана валидатора: например, валидатор полностью раскрывает себя.

### Fill or Kill и Immediate withdrawals
Если активирован *оптимистичный* режим, все равно снятия часто не могут быть обработаны немедленно, если у пула недостаточно TONов. В этом случае необходимо отчеканить счет на вывод средств, что может быть неоптимально для номинатора. В то же время иногда номинатор хочет дождаться конца раунда, чтобы получить прибыль этого раунда, даже если включен режим *оптимистичный*.
Для контроля такого поведения в запросах на сжигание есть два флага:
- `wait_till_round_end` - если `true`, то счет на вывод будет отчеканен независимо от возможности сделать немедленный вывод
- `fill_or_kill` - если `true` и нет достаточного количества TON, burn будет отменен путем майнинга пула джетонов обратно.


## Компоненты
### Контроллер
Контроллер учитывает средства валидатора и средства, взятые из Validation Pool. Он может обрабатывать депозиты от валидатора и из Validation Pool (позже Pool).
По запросу валидатора он может отправить ставку с его баланса на Elector. По запросу он может запросить вывод средств из Elector, но только после как минимум трех обновленных наборов валидатора ([здесь](https://github.com/ton-blockchain/nominator-pool/blob/main/func/pool.fc#L566) - вот почему это необходимо для правильного счета ставок). Таким образом, Контроллеру нужна возможность "считать" обновления наборов валидаторов, для этого существует запрос `update_set_hash`.
Как запросы на вывод средств, так и `update_set_hash` могут быть отправлены валидатором или, после льготного периода, кем угодно. В последнем случае отправитель получает вознаграждение из средств валидатора. Эта функциональность защищает от не отвечающего валидатора. 

Валидатор-контролер указывает в запросе на заем максимальную процентную ставку, минимальный и максимальный размер кредита TON. Валидатор может запрашивать только такие параметры, чтобы на его балансе были проценты плюс рекомендуемый штраф. Он может запросить средства только в том случае, если это одобрено Утвердителем.

После получения ставки от Избирателя Контроллер отправляет заемные средства плюс проценты в пул Удостоверяющего.

Обработчики входящих сообщений
- депозит (только из пула)
- обновление набора валидаторов (от валидатора или от кого-либо после льготного периода)
- требование запросить ставку у избирателя (от валидатора или любого другого лица после льготного периода)
- пополнить счет валидатора (только от валидатора)
- снять валидатор (только от валидатора)
- требование отправить ставку избирателю (только от валидатора)
- получить ставку от Избирателя (только от Избирателя)
- запросы управления (из Governance, Halter, Sudoer)
- одобрить/отказать в одобрении (от Approver)
отскоки
- отскакивание отправленной ставки избирателю (только от избирателя)

Исходящие сообщения:
- new_stake (для Elector)
- состояние запроса (для Elector)
- Запрос на заимствование (в Пул)
- Погашение долга (в Пул)
- вывод средств из Validator (в Validator)

[Подробная документация по контроллеру Validator](docs/controller.md)

Если у контроллера недостаточно активов для погашения долга после восстановления доли:
остановить контроллер и ожидать, что Governance "вручную" решит, что делать, например, подождать, пока валидатор пополнит запасы контроллера, или снять все в зависимости от условий.

### Пул

#### Часть контроллера
Обрабатывает запросы на кредитование от Validator Approvals: отправляет средства, если их достаточно, и запрашивает подходящую ставку и лимиты. Сохраняет в *активный список контроллеров* (предполагается, что их будет не более сотни).

Получает погашение долгов от валидаторов-контролеров: удаляет их из *активного списка контролеров*.

Учет гонораров: отправьте гонорар за управление в управление

Агрегирует данные о прибыли/убытках за каждый раунд, соотношение пул-джеттон/тонна, отправляет статистику менеджеру по процентам.


#### Пользовательская часть
Следит за соотношением пула jetton/TON.

Получает депозиты от номинантов и чеканит для них *Deposit*/*pool jetton*.

Получает уведомления о сгорании пула джеттон (запросы на вывод) с кошельков номинантов и майнит для них *Withdrawal*/*TON* или возвращает сгорание.

Отслеживает суммы выплат **текущего раунда** (Withdrawals/Deposits).

По событию агрегирования (окончание раунда кредитования):
- майнит пул джеттонов на майнер *Выплаты по депозитам* для распределения
- отправляет TONs майнеру *Withdrawal Payout* для выполнения снятий.

Обработчики входящих сообщений
- запрос на заем (только от контроллера)
- запросы на управление (от Governance, Halter, Sudoer)
- возврат долга (только от контроллера из *активного списка контроллеров*)
- депозиты (от любого пользователя)
- уведомления о сгорании (от пула кошельков jetton)
отскоки
- TODO

Исходящие сообщения:
- депозит контроллеру (контроллеру, вставить в список _активных контроллеров_)
- уведомление об агрегированной прибыли (менеджеру по процентам)
- вознаграждение Управляющему 
- монетный пул джеттон (для выплаты депозита и номинатора)
- TONs (для выплат при выводе средств и номинатора)

[Подробная документация по пулу](docs/pool.md)

### Джеттон пула
Джеттон, представляющий долю в активах пула. Он может быть реализован как DAO Jetton таким образом, что владельцы пула jetton смогут голосовать за обновления сетевого конфига.

### Выплаты

Отложенные до конца раунда депозиты/выплаты могут быть представлены на цепи в различной форме. Два основных подхода - это использование джеттонов и NFT.

### Выплата NFT
В этой схеме выплата - это коллекция NFT, а "конверсионное обязательство" - это NFT. Каждый раунд создаются новые коллекции выплат для депозита и вывода.

Когда вы вносите TON в пул, вы сразу же получаете счет на депозит. Позже, после окончания текущего раунда валидации и освобождения средств от Elector, выясняется правильное соотношение PoolJetton/TON, рассчитывается сумма PoolJetton, соответствующая общей стоимости депозитов, и отправляется в Deposit Collection. После этого Deposit Collection посылает *burn request* последнему отчеканенному NFT, что вызывает конвертацию этого NFT и симулятивно посылает *burn request* тонне предшествующего NFT. Здесь для итерации по всей коллекции используется идея, что НФТ - это связанный список.

Такая реализация позволяет отправлять обработанные депозиты/снятия другим пользователям в целом и позволяет автоконвертировать их в активы, когда они готовы. **В текущей реализации это основной используемый механизм**.
